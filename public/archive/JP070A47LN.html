<!DOCTYPE html><html lang="en">
<head profile="http://a9.com/-/spec/opensearch/1.1/">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="http://godoc.org//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" rel="stylesheet" />
<link href="http://godoc.org/-/site.css?v=83fa968c50840a0c43e964f10f0a754bc9fb77f1" rel="stylesheet" />
<title>reflect - GoDoc</title>
<meta name="twitter:title" content="Package reflect" />
<meta property="og:title" content="Package reflect" />
<meta name="description" content="Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types." />
<meta name="twitter:description" content="Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types." />
<meta property="og:description" content="Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types." />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@golang" />
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
<div class="container">
<div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a class="navbar-brand" href="http://godoc.org/"><strong>GoDoc</strong></a>
</div>
<div class="collapse navbar-collapse">
<ul class="nav navbar-nav">
<li><a href="http://godoc.org/">Home</a></li>
<li><a href="http://godoc.org/-/index">Index</a></li>
<li><a href="http://godoc.org/-/about">About</a></li>
</ul>
<form class="navbar-nav navbar-form navbar-right" id="x-search" action="/" role="search"><input class="form-control" id="x-search-query" type="text" name="q" placeholder="Search" /></form>
</div>
</div>
</nav>
<div class="container">
<div class="clearfix" id="x-projnav">
<a href="http://godoc.org/-/go">Go:</a>
<span class="text-muted">reflect</span>
<span class="pull-right">
<a href="#pkg-index">Index</a>
<span class="text-muted">|</span> <a href="#pkg-examples">Examples</a>
<span class="text-muted">|</span>
<a href="#pkg-files">Files</a>
</span>
</div>
<h2 id="pkg-overview">package reflect</h2>
<p><code>import "reflect"</code>
</p><p>
Package reflect implements run-time reflection, allowing a program to
manipulate objects with arbitrary types.  The typical use is to take a value
with static type interface{} and extract its dynamic type information by
calling TypeOf, which returns a Type.
</p>
<p>
A call to ValueOf returns a Value representing the run-time data.
Zero takes a Type and returns a Value representing a zero value
for that type.
</p>
<p>
See &#34;The Laws of Reflection&#34; for an introduction to reflection in Go:
<a href="https://golang.org/doc/articles/laws_of_reflection.html">https://golang.org/doc/articles/laws_of_reflection.html</a></p>
<h3 id="pkg-index" class="section-header">Index <a class="permalink" href="#pkg-index">&para;</a></h3>
<ul class="list-unstyled">
<li><a href="#Copy">func Copy(dst, src Value) int</a></li><li><a href="#DeepEqual">func DeepEqual(a1, a2 interface{}) bool</a></li><li><a href="#Select">func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</a></li>
<li><a href="#ChanDir">type ChanDir</a></li>
<ul>
<li><a href="#ChanDir.String">func (d ChanDir) String() string</a></li>
</ul>
<li><a href="#Kind">type Kind</a></li>
<ul>
<li><a href="#Kind.String">func (k Kind) String() string</a></li>
</ul>
<li><a href="#Method">type Method</a></li>
<li><a href="#SelectCase">type SelectCase</a></li>
<li><a href="#SelectDir">type SelectDir</a></li>
<li><a href="#SliceHeader">type SliceHeader</a></li>
<li><a href="#StringHeader">type StringHeader</a></li>
<li><a href="#StructField">type StructField</a></li>
<li><a href="#StructTag">type StructTag</a></li>
<ul>
<li><a href="#StructTag.Get">func (tag StructTag) Get(key string) string</a></li>
</ul>
<li><a href="#Type">type Type</a></li>
<ul>
<li><a href="#ArrayOf">func ArrayOf(count int, elem Type) Type</a></li><li><a href="#ChanOf">func ChanOf(dir ChanDir, t Type) Type</a></li><li><a href="#FuncOf">func FuncOf(in, out []Type, variadic bool) Type</a></li><li><a href="#MapOf">func MapOf(key, elem Type) Type</a></li><li><a href="#PtrTo">func PtrTo(t Type) Type</a></li><li><a href="#SliceOf">func SliceOf(t Type) Type</a></li><li><a href="#TypeOf">func TypeOf(i interface{}) Type</a></li>
</ul>
<li><a href="#Value">type Value</a></li>
<ul>
<li><a href="#Append">func Append(s Value, x ...Value) Value</a></li><li><a href="#AppendSlice">func AppendSlice(s, t Value) Value</a></li><li><a href="#Indirect">func Indirect(v Value) Value</a></li><li><a href="#MakeChan">func MakeChan(typ Type, buffer int) Value</a></li><li><a href="#MakeFunc">func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value</a></li><li><a href="#MakeMap">func MakeMap(typ Type) Value</a></li><li><a href="#MakeSlice">func MakeSlice(typ Type, len, cap int) Value</a></li><li><a href="#New">func New(typ Type) Value</a></li><li><a href="#NewAt">func NewAt(typ Type, p unsafe.Pointer) Value</a></li><li><a href="#ValueOf">func ValueOf(i interface{}) Value</a></li><li><a href="#Zero">func Zero(typ Type) Value</a></li>
<li><a href="#Value.Addr">func (v Value) Addr() Value</a></li><li><a href="#Value.Bool">func (v Value) Bool() bool</a></li><li><a href="#Value.Bytes">func (v Value) Bytes() []byte</a></li><li><a href="#Value.Call">func (v Value) Call(in []Value) []Value</a></li><li><a href="#Value.CallSlice">func (v Value) CallSlice(in []Value) []Value</a></li><li><a href="#Value.CanAddr">func (v Value) CanAddr() bool</a></li><li><a href="#Value.CanInterface">func (v Value) CanInterface() bool</a></li><li><a href="#Value.CanSet">func (v Value) CanSet() bool</a></li><li><a href="#Value.Cap">func (v Value) Cap() int</a></li><li><a href="#Value.Close">func (v Value) Close()</a></li><li><a href="#Value.Complex">func (v Value) Complex() complex128</a></li><li><a href="#Value.Convert">func (v Value) Convert(t Type) Value</a></li><li><a href="#Value.Elem">func (v Value) Elem() Value</a></li><li><a href="#Value.Field">func (v Value) Field(i int) Value</a></li><li><a href="#Value.FieldByIndex">func (v Value) FieldByIndex(index []int) Value</a></li><li><a href="#Value.FieldByName">func (v Value) FieldByName(name string) Value</a></li><li><a href="#Value.FieldByNameFunc">func (v Value) FieldByNameFunc(match func(string) bool) Value</a></li><li><a href="#Value.Float">func (v Value) Float() float64</a></li><li><a href="#Value.Index">func (v Value) Index(i int) Value</a></li><li><a href="#Value.Int">func (v Value) Int() int64</a></li><li><a href="#Value.Interface">func (v Value) Interface() (i interface{})</a></li><li><a href="#Value.InterfaceData">func (v Value) InterfaceData() [2]uintptr</a></li><li><a href="#Value.IsNil">func (v Value) IsNil() bool</a></li><li><a href="#Value.IsValid">func (v Value) IsValid() bool</a></li><li><a href="#Value.Kind">func (v Value) Kind() Kind</a></li><li><a href="#Value.Len">func (v Value) Len() int</a></li><li><a href="#Value.MapIndex">func (v Value) MapIndex(key Value) Value</a></li><li><a href="#Value.MapKeys">func (v Value) MapKeys() []Value</a></li><li><a href="#Value.Method">func (v Value) Method(i int) Value</a></li><li><a href="#Value.MethodByName">func (v Value) MethodByName(name string) Value</a></li><li><a href="#Value.NumField">func (v Value) NumField() int</a></li><li><a href="#Value.NumMethod">func (v Value) NumMethod() int</a></li><li><a href="#Value.OverflowComplex">func (v Value) OverflowComplex(x complex128) bool</a></li><li><a href="#Value.OverflowFloat">func (v Value) OverflowFloat(x float64) bool</a></li><li><a href="#Value.OverflowInt">func (v Value) OverflowInt(x int64) bool</a></li><li><a href="#Value.OverflowUint">func (v Value) OverflowUint(x uint64) bool</a></li><li><a href="#Value.Pointer">func (v Value) Pointer() uintptr</a></li><li><a href="#Value.Recv">func (v Value) Recv() (x Value, ok bool)</a></li><li><a href="#Value.Send">func (v Value) Send(x Value)</a></li><li><a href="#Value.Set">func (v Value) Set(x Value)</a></li><li><a href="#Value.SetBool">func (v Value) SetBool(x bool)</a></li><li><a href="#Value.SetBytes">func (v Value) SetBytes(x []byte)</a></li><li><a href="#Value.SetCap">func (v Value) SetCap(n int)</a></li><li><a href="#Value.SetComplex">func (v Value) SetComplex(x complex128)</a></li><li><a href="#Value.SetFloat">func (v Value) SetFloat(x float64)</a></li><li><a href="#Value.SetInt">func (v Value) SetInt(x int64)</a></li><li><a href="#Value.SetLen">func (v Value) SetLen(n int)</a></li><li><a href="#Value.SetMapIndex">func (v Value) SetMapIndex(key, val Value)</a></li><li><a href="#Value.SetPointer">func (v Value) SetPointer(x unsafe.Pointer)</a></li><li><a href="#Value.SetString">func (v Value) SetString(x string)</a></li><li><a href="#Value.SetUint">func (v Value) SetUint(x uint64)</a></li><li><a href="#Value.Slice">func (v Value) Slice(i, j int) Value</a></li><li><a href="#Value.Slice3">func (v Value) Slice3(i, j, k int) Value</a></li><li><a href="#Value.String">func (v Value) String() string</a></li><li><a href="#Value.TryRecv">func (v Value) TryRecv() (x Value, ok bool)</a></li><li><a href="#Value.TrySend">func (v Value) TrySend(x Value) bool</a></li><li><a href="#Value.Type">func (v Value) Type() Type</a></li><li><a href="#Value.Uint">func (v Value) Uint() uint64</a></li><li><a href="#Value.UnsafeAddr">func (v Value) UnsafeAddr() uintptr</a></li>
</ul>
<li><a href="#ValueError">type ValueError</a></li>
<ul>
<li><a href="#ValueError.Error">func (e *ValueError) Error() string</a></li>
</ul>
</ul>
<h4 id="pkg-examples">Examples <a class="permalink" href="#pkg-examples">&para;</a></h4>
<ul class="list-unstyled">
<li><a href="#example-MakeFunc" onclick="$('#ex-MakeFunc').addClass('in').removeClass('collapse').height('auto')">MakeFunc</a></li><li><a href="#example-StructTag" onclick="$('#ex-StructTag').addClass('in').removeClass('collapse').height('auto')">StructTag</a></li><li><a href="#example-TypeOf" onclick="$('#ex-TypeOf').addClass('in').removeClass('collapse').height('auto')">TypeOf</a></li>
</ul>
<h4 id="pkg-files">
<a href="https://golang.org/src/reflect/">Package Files</a>
<a class="permalink" href="#pkg-files">&para;</a>
</h4>
<p><a href="https://golang.org/src/reflect/deepequal.go">deepequal.go</a> <a href="https://golang.org/src/reflect/makefunc.go">makefunc.go</a> <a href="https://golang.org/src/reflect/type.go">type.go</a> <a href="https://golang.org/src/reflect/value.go">value.go</a> </p>
<h3 id="Copy" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L1831">Copy</a> <a class="permalink" href="#Copy">&para;</a></h3>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1831">❖</a><pre>func Copy(dst, src <a href="#Value">Value</a>) <a href="http://godoc.org/builtin#int">int</a></pre></div><p>
Copy copies the contents of src into dst until either
dst has been filled or src has been exhausted.
It returns the number of elements copied.
Dst and src each must have kind Slice or Array, and
dst and src must have the same element type.
</p>
<h3 id="DeepEqual" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/deepequal.go#L135">DeepEqual</a> <a class="permalink" href="#DeepEqual">&para;</a></h3>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/deepequal.go#L135">❖</a><pre>func DeepEqual(a1, a2 interface{}) <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
DeepEqual tests for deep equality. It uses normal == equality where
possible but will scan elements of arrays, slices, maps, and fields of
structs. In maps, keys are compared with == but elements use deep
equality. DeepEqual correctly handles recursive types. Functions are equal
only if they are both nil.
An empty slice is not equal to a nil slice.
</p>
<h3 id="Select" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L1928">Select</a> <a class="permalink" href="#Select">&para;</a></h3>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1928">❖</a><pre>func Select(cases []<a href="#SelectCase">SelectCase</a>) (chosen <a href="http://godoc.org/builtin#int">int</a>, recv <a href="#Value">Value</a>, recvOK <a href="http://godoc.org/builtin#bool">bool</a>)</pre></div><p>
Select executes a select operation described by the list of cases.
Like the Go select statement, it blocks until at least one of the cases
can proceed, makes a uniform pseudo-random choice,
and then executes that case. It returns the index of the chosen case
and, if that case was a receive operation, the value received and a
boolean indicating whether the value corresponds to a send on the channel
(as opposed to a zero value received because the channel is closed).
</p>
<h3 id="ChanDir" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/type.go#L294">ChanDir</a> <a class="permalink" href="#ChanDir">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/type.go#L294">❖</a><pre>type ChanDir <a href="http://godoc.org/builtin#int">int</a></pre></div><p>
ChanDir represents a channel type&#39;s direction.
</p>
<div class="decl" data-kind="c"><a title="View Source" href="https://golang.org/src/reflect/type.go#L296">❖</a><pre>const (
    <span id="RecvDir">RecvDir</span> <a href="#ChanDir">ChanDir</a>             = 1 &lt;&lt; <a href="http://godoc.org/builtin#iota">iota</a> <span class="com">// &lt;-chan</span>
    <span id="SendDir">SendDir</span>                                 <span class="com">// chan&lt;-</span>
    <span id="BothDir">BothDir</span> = <a href="#RecvDir">RecvDir</a> | <a href="#SendDir">SendDir</a>             <span class="com">// chan</span>
)</pre></div>
<h4 id="ChanDir.String" data-kind="m">func (ChanDir) <a title="View Source" href="https://golang.org/src/reflect/type.go#L690">String</a> <a class="permalink" href="#ChanDir.String">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L690">❖</a><pre>func (d <a href="#ChanDir">ChanDir</a>) String() <a href="http://godoc.org/builtin#string">string</a></pre></div>
<h3 id="Kind" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/type.go#L211">Kind</a> <a class="permalink" href="#Kind">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/type.go#L211">❖</a><pre>type Kind <a href="http://godoc.org/builtin#uint">uint</a></pre></div><p>
A Kind represents the specific kind of type that a Type represents.
The zero Kind is not a valid kind.
</p>
<div class="decl" data-kind="c"><a title="View Source" href="https://golang.org/src/reflect/type.go#L213">❖</a><pre>const (
    <span id="Invalid">Invalid</span> <a href="#Kind">Kind</a> = <a href="http://godoc.org/builtin#iota">iota</a>
    <span id="Bool">Bool</span>
    <span id="Int">Int</span>
    <span id="Int8">Int8</span>
    <span id="Int16">Int16</span>
    <span id="Int32">Int32</span>
    <span id="Int64">Int64</span>
    <span id="Uint">Uint</span>
    <span id="Uint8">Uint8</span>
    <span id="Uint16">Uint16</span>
    <span id="Uint32">Uint32</span>
    <span id="Uint64">Uint64</span>
    <span id="Uintptr">Uintptr</span>
    <span id="Float32">Float32</span>
    <span id="Float64">Float64</span>
    <span id="Complex64">Complex64</span>
    <span id="Complex128">Complex128</span>
    <span id="Array">Array</span>
    <span id="Chan">Chan</span>
    <span id="Func">Func</span>
    <span id="Interface">Interface</span>
    <span id="Map">Map</span>
    <span id="Ptr">Ptr</span>
    <span id="Slice">Slice</span>
    <span id="String">String</span>
    <span id="Struct">Struct</span>
    <span id="UnsafePointer">UnsafePointer</span>
)</pre></div>
<h4 id="Kind.String" data-kind="m">func (Kind) <a title="View Source" href="https://golang.org/src/reflect/type.go#L408">String</a> <a class="permalink" href="#Kind.String">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L408">❖</a><pre>func (k <a href="#Kind">Kind</a>) String() <a href="http://godoc.org/builtin#string">string</a></pre></div>
<h3 id="Method" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/type.go#L386">Method</a> <a class="permalink" href="#Method">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/type.go#L386">❖</a><pre>type Method struct {
    <span class="com">// Name is the method name.
    // PkgPath is the package path that qualifies a lower case (unexported)
    // method name.  It is empty for upper case (exported) method names.
    // The combination of PkgPath and Name uniquely identifies a method
    // in a method set.
    // See https://golang.org/ref/spec#Uniqueness_of_identifiers</span>
    <span id="Method.Name">Name</span>    <a href="http://godoc.org/builtin#string">string</a>
    <span id="Method.PkgPath">PkgPath</span> <a href="http://godoc.org/builtin#string">string</a>

    <span id="Method.Type">Type</span>  <a href="#Type">Type</a>  <span class="com">// method type</span>
    <span id="Method.Func">Func</span>  <a href="#Value">Value</a> <span class="com">// func with receiver as first argument</span>
    <span id="Method.Index">Index</span> <a href="http://godoc.org/builtin#int">int</a>   <span class="com">// index for Type.Method</span>
}</pre></div><p>
Method represents a single method.
</p>
<h3 id="SelectCase" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/value.go#L1915">SelectCase</a> <a class="permalink" href="#SelectCase">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1915">❖</a><pre>type SelectCase struct {
    <span id="SelectCase.Dir">Dir</span>  <a href="#SelectDir">SelectDir</a> <span class="com">// direction of case</span>
    <span id="SelectCase.Chan">Chan</span> <a href="#Value">Value</a>     <span class="com">// channel to use (for send or receive)</span>
    <span id="SelectCase.Send">Send</span> <a href="#Value">Value</a>     <span class="com">// value to send (for send)</span>
}</pre></div><p>
A SelectCase describes a single case in a select operation.
The kind of case depends on Dir, the communication direction.
</p>
<p>
If Dir is SelectDefault, the case represents a default case.
Chan and Send must be zero Values.
</p>
<p>
If Dir is SelectSend, the case represents a send operation.
Normally Chan&#39;s underlying value must be a channel, and Send&#39;s underlying value must be
assignable to the channel&#39;s element type. As a special case, if Chan is a zero Value,
then the case is ignored, and the field Send will also be ignored and may be either zero
or non-zero.
</p>
<p>
If Dir is SelectRecv, the case represents a receive operation.
Normally Chan&#39;s underlying value must be a channel and Send must be a zero Value.
If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.
When a receive operation is selected, the received Value is returned by Select.
</p>
<h3 id="SelectDir" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/value.go#L1887">SelectDir</a> <a class="permalink" href="#SelectDir">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1887">❖</a><pre>type SelectDir <a href="http://godoc.org/builtin#int">int</a></pre></div><p>
A SelectDir describes the communication direction of a select case.
</p>
<div class="decl" data-kind="c"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1891">❖</a><pre>const (
    <span id="SelectSend">SelectSend</span>    SelectDir <span class="com">// case Chan &lt;- Send</span>
    <span id="SelectRecv">SelectRecv</span>              <span class="com">// case &lt;-Chan:</span>
    <span id="SelectDefault">SelectDefault</span>           <span class="com">// default</span>
)</pre></div>
<h3 id="SliceHeader" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/value.go#L1751">SliceHeader</a> <a class="permalink" href="#SliceHeader">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1751">❖</a><pre>type SliceHeader struct {
    <span id="SliceHeader.Data">Data</span> <a href="http://godoc.org/builtin#uintptr">uintptr</a>
    <span id="SliceHeader.Len">Len</span>  <a href="http://godoc.org/builtin#int">int</a>
    <span id="SliceHeader.Cap">Cap</span>  <a href="http://godoc.org/builtin#int">int</a>
}</pre></div><p>
SliceHeader is the runtime representation of a slice.
It cannot be used safely or portably and its representation may
change in a later release.
Moreover, the Data field is not sufficient to guarantee the data
it references will not be garbage collected, so programs must keep
a separate, correctly typed pointer to the underlying data.
</p>
<h3 id="StringHeader" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/value.go#L1734">StringHeader</a> <a class="permalink" href="#StringHeader">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1734">❖</a><pre>type StringHeader struct {
    <span id="StringHeader.Data">Data</span> <a href="http://godoc.org/builtin#uintptr">uintptr</a>
    <span id="StringHeader.Len">Len</span>  <a href="http://godoc.org/builtin#int">int</a>
}</pre></div><p>
StringHeader is the runtime representation of a string.
It cannot be used safely or portably and its representation may
change in a later release.
Moreover, the Data field is not sufficient to guarantee the data
it references will not be garbage collected, so programs must keep
a separate, correctly typed pointer to the underlying data.
</p>
<h3 id="StructField" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/type.go#L736">StructField</a> <a class="permalink" href="#StructField">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/type.go#L736">❖</a><pre>type StructField struct {
    <span class="com">// Name is the field name.
    // PkgPath is the package path that qualifies a lower case (unexported)
    // field name.  It is empty for upper case (exported) field names.
    // See https://golang.org/ref/spec#Uniqueness_of_identifiers</span>
    <span id="StructField.Name">Name</span>    <a href="http://godoc.org/builtin#string">string</a>
    <span id="StructField.PkgPath">PkgPath</span> <a href="http://godoc.org/builtin#string">string</a>

    <span id="StructField.Type">Type</span>      <a href="#Type">Type</a>      <span class="com">// field type</span>
    <span id="StructField.Tag">Tag</span>       <a href="#StructTag">StructTag</a> <span class="com">// field tag string</span>
    <span id="StructField.Offset">Offset</span>    <a href="http://godoc.org/builtin#uintptr">uintptr</a>   <span class="com">// offset within struct, in bytes</span>
    <span id="StructField.Index">Index</span>     []<a href="http://godoc.org/builtin#int">int</a>     <span class="com">// index sequence for Type.FieldByIndex</span>
    <span id="StructField.Anonymous">Anonymous</span> <a href="http://godoc.org/builtin#bool">bool</a>      <span class="com">// is an embedded field</span>
}</pre></div><p>
A StructField describes a single field in a struct.
</p>
<h3 id="StructTag" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/type.go#L759">StructTag</a> <a class="permalink" href="#StructTag">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/type.go#L759">❖</a><pre>type StructTag <a href="http://godoc.org/builtin#string">string</a></pre></div><p>
A StructTag is the tag string in a struct field.
</p>
<p>
By convention, tag strings are a concatenation of
optionally space-separated key:&#34;value&#34; pairs.
Each key is a non-empty string consisting of non-control
characters other than space (U+0020 &#39; &#39;), quote (U+0022 &#39;&#34;&#39;),
and colon (U+003A &#39;:&#39;).  Each value is quoted using U+0022 &#39;&#34;&#39;
characters and Go string literal syntax.
</p>
<div class="panel-group">
<div class="panel panel-default" id="example-StructTag">
<div class="panel-heading"><a class="accordion-toggle" data-toggle="collapse" href="#ex-StructTag">Example</a></div>
<div id="ex-StructTag" class="panel-collapse collapse"><div class="panel-body">
<p>Code:<span class="pull-right"><a href="?play=StructTag">play</a>&nbsp;</span>
<pre>type S struct {
    F string `species:&#34;gopher&#34; color:&#34;blue&#34;`
}

s := S{}
st := reflect.TypeOf(s)
field := st.Field(0)
fmt.Println(field.Tag.Get(&#34;color&#34;), field.Tag.Get(&#34;species&#34;))</pre>
</p><p>Output:<pre>blue gopher
</pre>
</p></div></div>
</div>
</div>
<h4 id="StructTag.Get" data-kind="m">func (StructTag) <a title="View Source" href="https://golang.org/src/reflect/type.go#L765">Get</a> <a class="permalink" href="#StructTag.Get">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L765">❖</a><pre>func (tag <a href="#StructTag">StructTag</a>) Get(key <a href="http://godoc.org/builtin#string">string</a>) <a href="http://godoc.org/builtin#string">string</a></pre></div><p>
Get returns the value associated with key in the tag string.
If there is no such key in the tag, Get returns the empty string.
If the tag does not have the conventional format, the value
returned by Get is unspecified.
</p>
<h3 id="Type" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/type.go#L32">Type</a> <a class="permalink" href="#Type">&para;</a></h3>
<div class="decl" data-kind="m"><a title="View Source" href="https://golang.org/src/reflect/type.go#L32">❖</a><pre>type Type interface {

    <span class="com">// Align returns the alignment in bytes of a value of
    // this type when allocated in memory.</span>
    <span id="Type.Align">Align</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// FieldAlign returns the alignment in bytes of a value of
    // this type when used as a field in a struct.</span>
    <span id="Type.FieldAlign">FieldAlign</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// Method returns the i&#39;th method in the type&#39;s method set.
    // It panics if i is not in the range [0, NumMethod()).
    //
    // For a non-interface type T or *T, the returned Method&#39;s Type and Func
    // fields describe a function whose first argument is the receiver.
    //
    // For an interface type, the returned Method&#39;s Type field gives the
    // method signature, without a receiver, and the Func field is nil.</span>
    <span id="Type.Method">Method</span>(<a href="http://godoc.org/builtin#int">int</a>) <a href="#Method">Method</a>

    <span class="com">// MethodByName returns the method with that name in the type&#39;s
    // method set and a boolean indicating if the method was found.
    //
    // For a non-interface type T or *T, the returned Method&#39;s Type and Func
    // fields describe a function whose first argument is the receiver.
    //
    // For an interface type, the returned Method&#39;s Type field gives the
    // method signature, without a receiver, and the Func field is nil.</span>
    <span id="Type.MethodByName">MethodByName</span>(<a href="http://godoc.org/builtin#string">string</a>) (<a href="#Method">Method</a>, <a href="http://godoc.org/builtin#bool">bool</a>)

    <span class="com">// NumMethod returns the number of methods in the type&#39;s method set.</span>
    <span id="Type.NumMethod">NumMethod</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// Name returns the type&#39;s name within its package.
    // It returns an empty string for unnamed types.</span>
    <span id="Type.Name">Name</span>() <a href="http://godoc.org/builtin#string">string</a>

    <span class="com">// PkgPath returns a named type&#39;s package path, that is, the import path
    // that uniquely identifies the package, such as &#34;encoding/base64&#34;.
    // If the type was predeclared (string, error) or unnamed (*T, struct{}, []int),
    // the package path will be the empty string.</span>
    <span id="Type.PkgPath">PkgPath</span>() <a href="http://godoc.org/builtin#string">string</a>

    <span class="com">// Size returns the number of bytes needed to store
    // a value of the given type; it is analogous to unsafe.Sizeof.</span>
    <span id="Type.Size">Size</span>() <a href="http://godoc.org/builtin#uintptr">uintptr</a>

    <span class="com">// String returns a string representation of the type.
    // The string representation may use shortened package names
    // (e.g., base64 instead of &#34;encoding/base64&#34;) and is not
    // guaranteed to be unique among types.  To test for equality,
    // compare the Types directly.</span>
    <span id="Type.String">String</span>() <a href="http://godoc.org/builtin#string">string</a>

    <span class="com">// Kind returns the specific kind of this type.</span>
    <span id="Type.Kind">Kind</span>() <a href="#Kind">Kind</a>

    <span class="com">// Implements reports whether the type implements the interface type u.</span>
    <span id="Type.Implements">Implements</span>(u <a href="#Type">Type</a>) <a href="http://godoc.org/builtin#bool">bool</a>

    <span class="com">// AssignableTo reports whether a value of the type is assignable to type u.</span>
    <span id="Type.AssignableTo">AssignableTo</span>(u <a href="#Type">Type</a>) <a href="http://godoc.org/builtin#bool">bool</a>

    <span class="com">// ConvertibleTo reports whether a value of the type is convertible to type u.</span>
    <span id="Type.ConvertibleTo">ConvertibleTo</span>(u <a href="#Type">Type</a>) <a href="http://godoc.org/builtin#bool">bool</a>

    <span class="com">// Comparable reports whether values of this type are comparable.</span>
    <span id="Type.Comparable">Comparable</span>() <a href="http://godoc.org/builtin#bool">bool</a>

    <span class="com">// Bits returns the size of the type in bits.
    // It panics if the type&#39;s Kind is not one of the
    // sized or unsized Int, Uint, Float, or Complex kinds.</span>
    <span id="Type.Bits">Bits</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// ChanDir returns a channel type&#39;s direction.
    // It panics if the type&#39;s Kind is not Chan.</span>
    <span id="Type.ChanDir">ChanDir</span>() <a href="#ChanDir">ChanDir</a>

    <span class="com">// IsVariadic reports whether a function type&#39;s final input parameter
    // is a &#34;...&#34; parameter.  If so, t.In(t.NumIn() - 1) returns the parameter&#39;s
    // implicit actual type []T.
    //
    // For concreteness, if t represents func(x int, y ... float64), then
    //
    //	t.NumIn() == 2
    //	t.In(0) is the reflect.Type for &#34;int&#34;
    //	t.In(1) is the reflect.Type for &#34;[]float64&#34;
    //	t.IsVariadic() == true
    //
    // IsVariadic panics if the type&#39;s Kind is not Func.</span>
    <span id="Type.IsVariadic">IsVariadic</span>() <a href="http://godoc.org/builtin#bool">bool</a>

    <span class="com">// Elem returns a type&#39;s element type.
    // It panics if the type&#39;s Kind is not Array, Chan, Map, Ptr, or Slice.</span>
    <span id="Type.Elem">Elem</span>() <a href="#Type">Type</a>

    <span class="com">// Field returns a struct type&#39;s i&#39;th field.
    // It panics if the type&#39;s Kind is not Struct.
    // It panics if i is not in the range [0, NumField()).</span>
    <span id="Type.Field">Field</span>(i <a href="http://godoc.org/builtin#int">int</a>) <a href="#StructField">StructField</a>

    <span class="com">// FieldByIndex returns the nested field corresponding
    // to the index sequence.  It is equivalent to calling Field
    // successively for each index i.
    // It panics if the type&#39;s Kind is not Struct.</span>
    <span id="Type.FieldByIndex">FieldByIndex</span>(index []<a href="http://godoc.org/builtin#int">int</a>) <a href="#StructField">StructField</a>

    <span class="com">// FieldByName returns the struct field with the given name
    // and a boolean indicating if the field was found.</span>
    <span id="Type.FieldByName">FieldByName</span>(name <a href="http://godoc.org/builtin#string">string</a>) (<a href="#StructField">StructField</a>, <a href="http://godoc.org/builtin#bool">bool</a>)

    <span class="com">// FieldByNameFunc returns the first struct field with a name
    // that satisfies the match function and a boolean indicating if
    // the field was found.</span>
    <span id="Type.FieldByNameFunc">FieldByNameFunc</span>(match func(<a href="http://godoc.org/builtin#string">string</a>) <a href="http://godoc.org/builtin#bool">bool</a>) (<a href="#StructField">StructField</a>, <a href="http://godoc.org/builtin#bool">bool</a>)

    <span class="com">// In returns the type of a function type&#39;s i&#39;th input parameter.
    // It panics if the type&#39;s Kind is not Func.
    // It panics if i is not in the range [0, NumIn()).</span>
    <span id="Type.In">In</span>(i <a href="http://godoc.org/builtin#int">int</a>) <a href="#Type">Type</a>

    <span class="com">// Key returns a map type&#39;s key type.
    // It panics if the type&#39;s Kind is not Map.</span>
    <span id="Type.Key">Key</span>() <a href="#Type">Type</a>

    <span class="com">// Len returns an array type&#39;s length.
    // It panics if the type&#39;s Kind is not Array.</span>
    <span id="Type.Len">Len</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// NumField returns a struct type&#39;s field count.
    // It panics if the type&#39;s Kind is not Struct.</span>
    <span id="Type.NumField">NumField</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// NumIn returns a function type&#39;s input parameter count.
    // It panics if the type&#39;s Kind is not Func.</span>
    <span id="Type.NumIn">NumIn</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// NumOut returns a function type&#39;s output parameter count.
    // It panics if the type&#39;s Kind is not Func.</span>
    <span id="Type.NumOut">NumOut</span>() <a href="http://godoc.org/builtin#int">int</a>

    <span class="com">// Out returns the type of a function type&#39;s i&#39;th output parameter.
    // It panics if the type&#39;s Kind is not Func.
    // It panics if i is not in the range [0, NumOut()).</span>
    <span id="Type.Out">Out</span>(i <a href="http://godoc.org/builtin#int">int</a>) <a href="#Type">Type</a>
    <span class="com">// contains filtered or unexported methods</span>
}</pre></div><p>
Type is the representation of a Go type.
</p>
<p>
Not all methods apply to all kinds of types.  Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of type before
calling kind-specific methods.  Calling a method
inappropriate to the kind of type causes a run-time panic.
</p>
<h4 id="ArrayOf" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/type.go#L1825">ArrayOf</a> <a class="permalink" href="#ArrayOf">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L1825">❖</a><pre>func ArrayOf(count <a href="http://godoc.org/builtin#int">int</a>, elem <a href="#Type">Type</a>) <a href="#Type">Type</a></pre></div><p>
ArrayOf returns the array type with the given count and element type.
For example, if t represents int, ArrayOf(5, t) represents [5]int.
</p>
<p>
If the resulting type would be larger than the available address space,
ArrayOf panics.
</p>
<h4 id="ChanOf" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/type.go#L1422">ChanOf</a> <a class="permalink" href="#ChanOf">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L1422">❖</a><pre>func ChanOf(dir <a href="#ChanDir">ChanDir</a>, t <a href="#Type">Type</a>) <a href="#Type">Type</a></pre></div><p>
ChanOf returns the channel type with the given direction and element type.
For example, if t represents int, ChanOf(RecvDir, t) represents &lt;-chan int.
</p>
<p>
The gc runtime imposes a limit of 64 kB on channel element types.
If t&#39;s size is equal to or exceeds this limit, ChanOf panics.
</p>
<h4 id="FuncOf" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/type.go#L1542">FuncOf</a> <a class="permalink" href="#FuncOf">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L1542">❖</a><pre>func FuncOf(in, out []<a href="#Type">Type</a>, variadic <a href="http://godoc.org/builtin#bool">bool</a>) <a href="#Type">Type</a></pre></div><p>
FuncOf returns the function type with the given argument and result types.
For example if k represents int and e represents string,
FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.
</p>
<p>
The variadic argument controls whether the function is variadic. FuncOf
panics if the in[len(in)-1] does not represent a slice and variadic is
true.
</p>
<h4 id="MapOf" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/type.go#L1481">MapOf</a> <a class="permalink" href="#MapOf">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L1481">❖</a><pre>func MapOf(key, elem <a href="#Type">Type</a>) <a href="#Type">Type</a></pre></div><p>
MapOf returns the map type with the given key and element types.
For example, if k represents int and e represents string,
MapOf(k, e) represents map[int]string.
</p>
<p>
If the key type is not a valid map key type (that is, if it does
not implement Go&#39;s == operator), MapOf panics.
</p>
<h4 id="PtrTo" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/type.go#L1028">PtrTo</a> <a class="permalink" href="#PtrTo">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L1028">❖</a><pre>func PtrTo(t <a href="#Type">Type</a>) <a href="#Type">Type</a></pre></div><p>
PtrTo returns the pointer type with element t.
For example, if t represents type Foo, PtrTo(t) represents *Foo.
</p>
<h4 id="SliceOf" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/type.go#L1785">SliceOf</a> <a class="permalink" href="#SliceOf">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L1785">❖</a><pre>func SliceOf(t <a href="#Type">Type</a>) <a href="#Type">Type</a></pre></div><p>
SliceOf returns the slice type with element type t.
For example, if t represents int, SliceOf(t) represents []int.
</p>
<h4 id="TypeOf" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/type.go#L1015">TypeOf</a> <a class="permalink" href="#TypeOf">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/type.go#L1015">❖</a><pre>func TypeOf(i interface{}) <a href="#Type">Type</a></pre></div><p>
TypeOf returns the reflection Type that represents the dynamic type of i.
If i is a nil interface value, TypeOf returns nil.
</p>
<div class="panel-group">
<div class="panel panel-default" id="example-TypeOf">
<div class="panel-heading"><a class="accordion-toggle" data-toggle="collapse" href="#ex-TypeOf">Example</a></div>
<div id="ex-TypeOf" class="panel-collapse collapse"><div class="panel-body">
<p>Code:<span class="pull-right"><a href="?play=TypeOf">play</a>&nbsp;</span>
<pre><span class="com">// As interface types are only used for static typing, a
// common idiom to find the reflection Type for an interface
// type Foo is to use a *Foo value.</span>
writerType := reflect.TypeOf((*io.Writer)(nil)).Elem()

fileType := reflect.TypeOf((*os.File)(nil))
fmt.Println(fileType.Implements(writerType))</pre>
</p><p>Output:<pre>true
</pre>
</p></div></div>
</div>
</div>
<h3 id="Value" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/value.go#L37">Value</a> <a class="permalink" href="#Value">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/value.go#L37">❖</a><pre>type Value struct {
    <span class="com">// contains filtered or unexported fields</span>
}</pre></div><p>
Value is the reflection interface to a Go value.
</p>
<p>
Not all methods apply to all kinds of values.  Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of value before
calling kind-specific methods.  Calling a method
inappropriate to the kind of type causes a run time panic.
</p>
<p>
The zero Value represents no value.
Its IsValid method returns false, its Kind method returns Invalid,
its String method returns &#34;&lt;invalid Value&gt;&#34;, and all other methods panic.
Most functions and methods never return an invalid value.
If one does, its documentation states the conditions explicitly.
</p>
<p>
A Value can be used concurrently by multiple goroutines provided that
the underlying Go value can be used concurrently for the equivalent
direct operations.
</p>
<p>
Using == on two Values does not compare the underlying values
they represent, but rather the contents of the Value structs.
To compare two Values, compare the results of the Interface method.
</p>
<h4 id="Append" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L1806">Append</a> <a class="permalink" href="#Append">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1806">❖</a><pre>func Append(s <a href="#Value">Value</a>, x ...<a href="#Value">Value</a>) <a href="#Value">Value</a></pre></div><p>
Append appends the values x to a slice s and returns the resulting slice.
As in Go, each x&#39;s value must be assignable to the slice&#39;s element type.
</p>
<h4 id="AppendSlice" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L1817">AppendSlice</a> <a class="permalink" href="#AppendSlice">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1817">❖</a><pre>func AppendSlice(s, t <a href="#Value">Value</a>) <a href="#Value">Value</a></pre></div><p>
AppendSlice appends a slice t to a slice s and returns the resulting slice.
The slices s and t must have the same element type.
</p>
<h4 id="Indirect" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2068">Indirect</a> <a class="permalink" href="#Indirect">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2068">❖</a><pre>func Indirect(v <a href="#Value">Value</a>) <a href="#Value">Value</a></pre></div><p>
Indirect returns the value that v points to.
If v is a nil pointer, Indirect returns a zero Value.
If v is not a pointer, Indirect returns v.
</p>
<h4 id="MakeChan" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2042">MakeChan</a> <a class="permalink" href="#MakeChan">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2042">❖</a><pre>func MakeChan(typ <a href="#Type">Type</a>, buffer <a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
MakeChan creates a new channel with the specified type and buffer size.
</p>
<h4 id="MakeFunc" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/makefunc.go#L44">MakeFunc</a> <a class="permalink" href="#MakeFunc">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/makefunc.go#L44">❖</a><pre>func MakeFunc(typ <a href="#Type">Type</a>, fn func(args []<a href="#Value">Value</a>) (results []<a href="#Value">Value</a>)) <a href="#Value">Value</a></pre></div><p>
MakeFunc returns a new function of the given Type
that wraps the function fn. When called, that new function
does the following:
</p>
<pre>- converts its arguments to a slice of Values.
- runs results := fn(args).
- returns the results as a slice of Values, one per formal result.
</pre>
<p>
The implementation fn can assume that the argument Value slice
has the number and type of arguments given by typ.
If typ describes a variadic function, the final Value is itself
a slice representing the variadic arguments, as in the
body of a variadic function. The result Value slice returned by fn
must have the number and type of results given by typ.
</p>
<p>
The Value.Call method allows the caller to invoke a typed function
in terms of Values; in contrast, MakeFunc allows the caller to implement
a typed function in terms of Values.
</p>
<p>
The Examples section of the documentation includes an illustration
of how to use MakeFunc to build a swap function for different types.
</p>
<div class="panel-group">
<div class="panel panel-default" id="example-MakeFunc">
<div class="panel-heading"><a class="accordion-toggle" data-toggle="collapse" href="#ex-MakeFunc">Example</a></div>
<div id="ex-MakeFunc" class="panel-collapse collapse"><div class="panel-body">
<p>Code:<span class="pull-right"><a href="?play=MakeFunc">play</a>&nbsp;</span>
<pre><span class="com">// swap is the implementation passed to MakeFunc.
// It must work in terms of reflect.Values so that it is possible
// to write code without knowing beforehand what the types
// will be.</span>
swap := func(in []reflect.Value) []reflect.Value {
    return []reflect.Value{in[1], in[0]}
}

<span class="com">// makeSwap expects fptr to be a pointer to a nil function.
// It sets that pointer to a new function created with MakeFunc.
// When the function is invoked, reflect turns the arguments
// into Values, calls swap, and then turns swap&#39;s result slice
// into the values returned by the new function.</span>
makeSwap := func(fptr interface{}) {
    <span class="com">// fptr is a pointer to a function.
    // Obtain the function value itself (likely nil) as a reflect.Value
    // so that we can query its type and then set the value.</span>
    fn := reflect.ValueOf(fptr).Elem()

    <span class="com">// Make a function of the right type.</span>
    v := reflect.MakeFunc(fn.Type(), swap)

    <span class="com">// Assign it to the value fn represents.</span>
    fn.Set(v)
}

<span class="com">// Make and call a swap function for ints.</span>
var intSwap func(int, int) (int, int)
makeSwap(&amp;intSwap)
fmt.Println(intSwap(0, 1))

<span class="com">// Make and call a swap function for float64s.</span>
var floatSwap func(float64, float64) (float64, float64)
makeSwap(&amp;floatSwap)
fmt.Println(floatSwap(2.72, 3.14))</pre>
</p><p>Output:<pre>1 0
3.14 2.72
</pre>
</p></div></div>
</div>
</div>
<h4 id="MakeMap" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2057">MakeMap</a> <a class="permalink" href="#MakeMap">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2057">❖</a><pre>func MakeMap(typ <a href="#Type">Type</a>) <a href="#Value">Value</a></pre></div><p>
MakeMap creates a new map of the specified type.
</p>
<h4 id="MakeSlice" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2023">MakeSlice</a> <a class="permalink" href="#MakeSlice">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2023">❖</a><pre>func MakeSlice(typ <a href="#Type">Type</a>, len, cap <a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
MakeSlice creates a new zero-initialized slice value
for the specified slice type, length, and capacity.
</p>
<h4 id="New" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2111">New</a> <a class="permalink" href="#New">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2111">❖</a><pre>func New(typ <a href="#Type">Type</a>) <a href="#Value">Value</a></pre></div><p>
New returns a Value representing a pointer to a new zero value
for the specified type.  That is, the returned Value&#39;s Type is PtrTo(typ).
</p>
<h4 id="NewAt" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2122">NewAt</a> <a class="permalink" href="#NewAt">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2122">❖</a><pre>func NewAt(typ <a href="#Type">Type</a>, p <a href="http://godoc.org/unsafe">unsafe</a>.<a href="http://godoc.org/unsafe#Pointer">Pointer</a>) <a href="#Value">Value</a></pre></div><p>
NewAt returns a Value representing a pointer to a value of the
specified type, using p as that pointer.
</p>
<h4 id="ValueOf" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2077">ValueOf</a> <a class="permalink" href="#ValueOf">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2077">❖</a><pre>func ValueOf(i interface{}) <a href="#Value">Value</a></pre></div><p>
ValueOf returns a new Value initialized to the concrete value
stored in the interface i.  ValueOf(nil) returns the zero Value.
</p>
<h4 id="Zero" data-kind="f">func <a title="View Source" href="https://golang.org/src/reflect/value.go#L2097">Zero</a> <a class="permalink" href="#Zero">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2097">❖</a><pre>func Zero(typ <a href="#Type">Type</a>) <a href="#Value">Value</a></pre></div><p>
Zero returns a Value representing the zero value for the specified type.
The result is different from the zero value of the Value struct,
which represents no value at all.
For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.
The returned value is neither addressable nor settable.
</p>
<h4 id="Value.Addr" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L235">Addr</a> <a class="permalink" href="#Value.Addr">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L235">❖</a><pre>func (v <a href="#Value">Value</a>) Addr() <a href="#Value">Value</a></pre></div><p>
Addr returns a pointer value representing the address of v.
It panics if CanAddr() returns false.
Addr is typically used to obtain a pointer to a struct field
or slice element in order to call a method that requires a
pointer receiver.
</p>
<h4 id="Value.Bool" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L244">Bool</a> <a class="permalink" href="#Value.Bool">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L244">❖</a><pre>func (v <a href="#Value">Value</a>) Bool() <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
Bool returns v&#39;s underlying value.
It panics if v&#39;s kind is not Bool.
</p>
<h4 id="Value.Bytes" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L251">Bytes</a> <a class="permalink" href="#Value.Bytes">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L251">❖</a><pre>func (v <a href="#Value">Value</a>) Bytes() []<a href="http://godoc.org/builtin#byte">byte</a></pre></div><p>
Bytes returns v&#39;s underlying value.
It panics if v&#39;s underlying value is not a slice of bytes.
</p>
<h4 id="Value.Call" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L297">Call</a> <a class="permalink" href="#Value.Call">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L297">❖</a><pre>func (v <a href="#Value">Value</a>) Call(in []<a href="#Value">Value</a>) []<a href="#Value">Value</a></pre></div><p>
Call calls the function v with the input arguments in.
For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
Call panics if v&#39;s Kind is not Func.
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function&#39;s corresponding input parameter.
If v is a variadic function, Call creates the variadic slice parameter
itself, copying in the corresponding values.
</p>
<h4 id="Value.CallSlice" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L310">CallSlice</a> <a class="permalink" href="#Value.CallSlice">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L310">❖</a><pre>func (v <a href="#Value">Value</a>) CallSlice(in []<a href="#Value">Value</a>) []<a href="#Value">Value</a></pre></div><p>
CallSlice calls the variadic function v with the input arguments in,
assigning the slice in[len(in)-1] to v&#39;s final variadic argument.
For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).
CallSlice panics if v&#39;s Kind is not Func or if v is not variadic.
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function&#39;s corresponding input parameter.
</p>
<h4 id="Value.CanAddr" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L276">CanAddr</a> <a class="permalink" href="#Value.CanAddr">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L276">❖</a><pre>func (v <a href="#Value">Value</a>) CanAddr() <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
CanAddr reports whether the value&#39;s address can be obtained with Addr.
Such values are called addressable.  A value is addressable if it is
an element of a slice, an element of an addressable array,
a field of an addressable struct, or the result of dereferencing a pointer.
If CanAddr returns false, calling Addr will panic.
</p>
<h4 id="Value.CanInterface" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L888">CanInterface</a> <a class="permalink" href="#Value.CanInterface">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L888">❖</a><pre>func (v <a href="#Value">Value</a>) CanInterface() <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
CanInterface reports whether Interface can be used without panicking.
</p>
<h4 id="Value.CanSet" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L285">CanSet</a> <a class="permalink" href="#Value.CanSet">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L285">❖</a><pre>func (v <a href="#Value">Value</a>) CanSet() <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
CanSet reports whether the value of v can be changed.
A Value can be changed only if it is addressable and was not
obtained by the use of unexported struct fields.
If CanSet returns false, calling Set or any type-specific
setter (e.g., SetBool, SetInt) will panic.
</p>
<h4 id="Value.Cap" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L661">Cap</a> <a class="permalink" href="#Value.Cap">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L661">❖</a><pre>func (v <a href="#Value">Value</a>) Cap() <a href="http://godoc.org/builtin#int">int</a></pre></div><p>
Cap returns v&#39;s capacity.
It panics if v&#39;s Kind is not Array, Chan, or Slice.
</p>
<h4 id="Value.Close" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L677">Close</a> <a class="permalink" href="#Value.Close">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L677">❖</a><pre>func (v <a href="#Value">Value</a>) Close()</pre></div><p>
Close closes the channel v.
It panics if v&#39;s Kind is not Chan.
</p>
<h4 id="Value.Complex" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L685">Complex</a> <a class="permalink" href="#Value.Complex">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L685">❖</a><pre>func (v <a href="#Value">Value</a>) Complex() <a href="http://godoc.org/builtin#complex128">complex128</a></pre></div><p>
Complex returns v&#39;s underlying value, as a complex128.
It panics if v&#39;s Kind is not Complex64 or Complex128
</p>
<h4 id="Value.Convert" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L2164">Convert</a> <a class="permalink" href="#Value.Convert">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L2164">❖</a><pre>func (v <a href="#Value">Value</a>) Convert(t <a href="#Type">Type</a>) <a href="#Value">Value</a></pre></div><p>
Convert returns the value v converted to type t.
If the usual Go conversion rules do not allow conversion
of the value v to type t, Convert panics.
</p>
<h4 id="Value.Elem" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L700">Elem</a> <a class="permalink" href="#Value.Elem">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L700">❖</a><pre>func (v <a href="#Value">Value</a>) Elem() <a href="#Value">Value</a></pre></div><p>
Elem returns the value that the interface v contains
or that the pointer v points to.
It panics if v&#39;s Kind is not Interface or Ptr.
It returns the zero Value if v is nil.
</p>
<h4 id="Value.Field" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L737">Field</a> <a class="permalink" href="#Value.Field">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L737">❖</a><pre>func (v <a href="#Value">Value</a>) Field(i <a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
Field returns the i&#39;th field of the struct v.
It panics if v&#39;s Kind is not Struct or i is out of range.
</p>
<h4 id="Value.FieldByIndex" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L765">FieldByIndex</a> <a class="permalink" href="#Value.FieldByIndex">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L765">❖</a><pre>func (v <a href="#Value">Value</a>) FieldByIndex(index []<a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
FieldByIndex returns the nested field corresponding to index.
It panics if v&#39;s Kind is not struct.
</p>
<h4 id="Value.FieldByName" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L787">FieldByName</a> <a class="permalink" href="#Value.FieldByName">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L787">❖</a><pre>func (v <a href="#Value">Value</a>) FieldByName(name <a href="http://godoc.org/builtin#string">string</a>) <a href="#Value">Value</a></pre></div><p>
FieldByName returns the struct field with the given name.
It returns the zero Value if no field was found.
It panics if v&#39;s Kind is not struct.
</p>
<h4 id="Value.FieldByNameFunc" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L799">FieldByNameFunc</a> <a class="permalink" href="#Value.FieldByNameFunc">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L799">❖</a><pre>func (v <a href="#Value">Value</a>) FieldByNameFunc(match func(<a href="http://godoc.org/builtin#string">string</a>) <a href="http://godoc.org/builtin#bool">bool</a>) <a href="#Value">Value</a></pre></div><p>
FieldByNameFunc returns the struct field with a name
that satisfies the match function.
It panics if v&#39;s Kind is not struct.
It returns the zero Value if no field was found.
</p>
<h4 id="Value.Float" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L808">Float</a> <a class="permalink" href="#Value.Float">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L808">❖</a><pre>func (v <a href="#Value">Value</a>) Float() <a href="http://godoc.org/builtin#float64">float64</a></pre></div><p>
Float returns v&#39;s underlying value, as a float64.
It panics if v&#39;s Kind is not Float32 or Float64
</p>
<h4 id="Value.Index" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L823">Index</a> <a class="permalink" href="#Value.Index">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L823">❖</a><pre>func (v <a href="#Value">Value</a>) Index(i <a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
Index returns v&#39;s i&#39;th element.
It panics if v&#39;s Kind is not Array, Slice, or String or i is out of range.
</p>
<h4 id="Value.Int" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L869">Int</a> <a class="permalink" href="#Value.Int">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L869">❖</a><pre>func (v <a href="#Value">Value</a>) Int() <a href="http://godoc.org/builtin#int64">int64</a></pre></div><p>
Int returns v&#39;s underlying value, as an int64.
It panics if v&#39;s Kind is not Int, Int8, Int16, Int32, or Int64.
</p>
<h4 id="Value.Interface" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L900">Interface</a> <a class="permalink" href="#Value.Interface">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L900">❖</a><pre>func (v <a href="#Value">Value</a>) Interface() (i interface{})</pre></div><p>
Interface returns v&#39;s current value as an interface{}.
It is equivalent to:
</p>
<pre>var i interface{} = (v&#39;s underlying value)
</pre>
<p>
It panics if the Value was obtained by accessing
unexported struct fields.
</p>
<h4 id="Value.InterfaceData" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L936">InterfaceData</a> <a class="permalink" href="#Value.InterfaceData">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L936">❖</a><pre>func (v <a href="#Value">Value</a>) InterfaceData() [2]<a href="http://godoc.org/builtin#uintptr">uintptr</a></pre></div><p>
InterfaceData returns the interface v&#39;s value as a uintptr pair.
It panics if v&#39;s Kind is not Interface.
</p>
<h4 id="Value.IsNil" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L954">IsNil</a> <a class="permalink" href="#Value.IsNil">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L954">❖</a><pre>func (v <a href="#Value">Value</a>) IsNil() <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
IsNil reports whether its argument v is nil. The argument must be
a chan, func, interface, map, pointer, or slice value; if it is
not, IsNil panics. Note that IsNil is not always equivalent to a
regular comparison with nil in Go. For example, if v was created
by calling ValueOf with an uninitialized interface variable i,
i==nil will be true but v.IsNil will panic as v will be the zero
Value.
</p>
<h4 id="Value.IsValid" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L979">IsValid</a> <a class="permalink" href="#Value.IsValid">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L979">❖</a><pre>func (v <a href="#Value">Value</a>) IsValid() <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
IsValid reports whether v represents a value.
It returns false if v is the zero Value.
If IsValid returns false, all other methods except String panic.
Most functions and methods never return an invalid value.
If one does, its documentation states the conditions explicitly.
</p>
<h4 id="Value.Kind" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L985">Kind</a> <a class="permalink" href="#Value.Kind">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L985">❖</a><pre>func (v <a href="#Value">Value</a>) Kind() <a href="#Kind">Kind</a></pre></div><p>
Kind returns v&#39;s Kind.
If v is the zero Value (IsValid returns false), Kind returns Invalid.
</p>
<h4 id="Value.Len" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L991">Len</a> <a class="permalink" href="#Value.Len">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L991">❖</a><pre>func (v <a href="#Value">Value</a>) Len() <a href="http://godoc.org/builtin#int">int</a></pre></div><p>
Len returns v&#39;s length.
It panics if v&#39;s Kind is not Array, Chan, Map, Slice, or String.
</p>
<h4 id="Value.MapIndex" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1015">MapIndex</a> <a class="permalink" href="#Value.MapIndex">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1015">❖</a><pre>func (v <a href="#Value">Value</a>) MapIndex(key <a href="#Value">Value</a>) <a href="#Value">Value</a></pre></div><p>
MapIndex returns the value associated with key in the map v.
It panics if v&#39;s Kind is not Map.
It returns the zero Value if key is not found in the map or if v represents a nil map.
As in Go, the key&#39;s value must be assignable to the map&#39;s key type.
</p>
<h4 id="Value.MapKeys" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1056">MapKeys</a> <a class="permalink" href="#Value.MapKeys">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1056">❖</a><pre>func (v <a href="#Value">Value</a>) MapKeys() []<a href="#Value">Value</a></pre></div><p>
MapKeys returns a slice containing all the keys present in the map,
in unspecified order.
It panics if v&#39;s Kind is not Map.
It returns an empty slice if v represents a nil map.
</p>
<h4 id="Value.Method" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1097">Method</a> <a class="permalink" href="#Value.Method">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1097">❖</a><pre>func (v <a href="#Value">Value</a>) Method(i <a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
Method returns a function value corresponding to v&#39;s i&#39;th method.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
Method panics if i is out of range or if v is a nil interface value.
</p>
<h4 id="Value.MethodByName" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1129">MethodByName</a> <a class="permalink" href="#Value.MethodByName">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1129">❖</a><pre>func (v <a href="#Value">Value</a>) MethodByName(name <a href="http://godoc.org/builtin#string">string</a>) <a href="#Value">Value</a></pre></div><p>
MethodByName returns a function value corresponding to the method
of v with the given name.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
It returns the zero Value if no method was found.
</p>
<h4 id="Value.NumField" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1145">NumField</a> <a class="permalink" href="#Value.NumField">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1145">❖</a><pre>func (v <a href="#Value">Value</a>) NumField() <a href="http://godoc.org/builtin#int">int</a></pre></div><p>
NumField returns the number of fields in the struct v.
It panics if v&#39;s Kind is not Struct.
</p>
<h4 id="Value.NumMethod" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1114">NumMethod</a> <a class="permalink" href="#Value.NumMethod">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1114">❖</a><pre>func (v <a href="#Value">Value</a>) NumMethod() <a href="http://godoc.org/builtin#int">int</a></pre></div><p>
NumMethod returns the number of methods in the value&#39;s method set.
</p>
<h4 id="Value.OverflowComplex" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1153">OverflowComplex</a> <a class="permalink" href="#Value.OverflowComplex">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1153">❖</a><pre>func (v <a href="#Value">Value</a>) OverflowComplex(x <a href="http://godoc.org/builtin#complex128">complex128</a>) <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
OverflowComplex reports whether the complex128 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Complex64 or Complex128.
</p>
<h4 id="Value.OverflowFloat" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1166">OverflowFloat</a> <a class="permalink" href="#Value.OverflowFloat">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1166">❖</a><pre>func (v <a href="#Value">Value</a>) OverflowFloat(x <a href="http://godoc.org/builtin#float64">float64</a>) <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
OverflowFloat reports whether the float64 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Float32 or Float64.
</p>
<h4 id="Value.OverflowInt" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1186">OverflowInt</a> <a class="permalink" href="#Value.OverflowInt">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1186">❖</a><pre>func (v <a href="#Value">Value</a>) OverflowInt(x <a href="http://godoc.org/builtin#int64">int64</a>) <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
OverflowInt reports whether the int64 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Int, Int8, int16, Int32, or Int64.
</p>
<h4 id="Value.OverflowUint" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1199">OverflowUint</a> <a class="permalink" href="#Value.OverflowUint">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1199">❖</a><pre>func (v <a href="#Value">Value</a>) OverflowUint(x <a href="http://godoc.org/builtin#uint64">uint64</a>) <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
OverflowUint reports whether the uint64 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
</p>
<h4 id="Value.Pointer" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1224">Pointer</a> <a class="permalink" href="#Value.Pointer">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1224">❖</a><pre>func (v <a href="#Value">Value</a>) Pointer() <a href="http://godoc.org/builtin#uintptr">uintptr</a></pre></div><p>
Pointer returns v&#39;s value as a uintptr.
It returns uintptr instead of unsafe.Pointer so that
code using reflect cannot obtain unsafe.Pointers
without importing the unsafe package explicitly.
It panics if v&#39;s Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.
</p>
<p>
If v&#39;s Kind is Func, the returned pointer is an underlying
code pointer, but not necessarily enough to identify a
single function uniquely. The only guarantee is that the
result is zero if and only if v is a nil func Value.
</p>
<p>
If v&#39;s Kind is Slice, the returned pointer is to the first
element of the slice.  If the slice is nil the returned value
is 0.  If the slice is empty but non-nil the return value is non-zero.
</p>
<h4 id="Value.Recv" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1260">Recv</a> <a class="permalink" href="#Value.Recv">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1260">❖</a><pre>func (v <a href="#Value">Value</a>) Recv() (x <a href="#Value">Value</a>, ok <a href="http://godoc.org/builtin#bool">bool</a>)</pre></div><p>
Recv receives and returns a value from the channel v.
It panics if v&#39;s Kind is not Chan.
The receive blocks until a value is ready.
The boolean value ok is true if the value x corresponds to a send
on the channel, false if it is a zero value received because the channel is closed.
</p>
<h4 id="Value.Send" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1293">Send</a> <a class="permalink" href="#Value.Send">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1293">❖</a><pre>func (v <a href="#Value">Value</a>) Send(x <a href="#Value">Value</a>)</pre></div><p>
Send sends x on the channel v.
It panics if v&#39;s kind is not Chan or if x&#39;s type is not the same type as v&#39;s element type.
As in Go, x&#39;s value must be assignable to the channel&#39;s element type.
</p>
<h4 id="Value.Set" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1320">Set</a> <a class="permalink" href="#Value.Set">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1320">❖</a><pre>func (v <a href="#Value">Value</a>) Set(x <a href="#Value">Value</a>)</pre></div><p>
Set assigns x to the value v.
It panics if CanSet returns false.
As in Go, x&#39;s value must be assignable to v&#39;s type.
</p>
<h4 id="Value.SetBool" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1337">SetBool</a> <a class="permalink" href="#Value.SetBool">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1337">❖</a><pre>func (v <a href="#Value">Value</a>) SetBool(x <a href="http://godoc.org/builtin#bool">bool</a>)</pre></div><p>
SetBool sets v&#39;s underlying value.
It panics if v&#39;s Kind is not Bool or if CanSet() is false.
</p>
<h4 id="Value.SetBytes" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1345">SetBytes</a> <a class="permalink" href="#Value.SetBytes">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1345">❖</a><pre>func (v <a href="#Value">Value</a>) SetBytes(x []<a href="http://godoc.org/builtin#byte">byte</a>)</pre></div><p>
SetBytes sets v&#39;s underlying value.
It panics if v&#39;s underlying value is not a slice of bytes.
</p>
<h4 id="Value.SetCap" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1429">SetCap</a> <a class="permalink" href="#Value.SetCap">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1429">❖</a><pre>func (v <a href="#Value">Value</a>) SetCap(n <a href="http://godoc.org/builtin#int">int</a>)</pre></div><p>
SetCap sets v&#39;s capacity to n.
It panics if v&#39;s Kind is not Slice or if n is smaller than the length or
greater than the capacity of the slice.
</p>
<h4 id="Value.SetComplex" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1367">SetComplex</a> <a class="permalink" href="#Value.SetComplex">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1367">❖</a><pre>func (v <a href="#Value">Value</a>) SetComplex(x <a href="http://godoc.org/builtin#complex128">complex128</a>)</pre></div><p>
SetComplex sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Complex64 or Complex128, or if CanSet() is false.
</p>
<h4 id="Value.SetFloat" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1381">SetFloat</a> <a class="permalink" href="#Value.SetFloat">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1381">❖</a><pre>func (v <a href="#Value">Value</a>) SetFloat(x <a href="http://godoc.org/builtin#float64">float64</a>)</pre></div><p>
SetFloat sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Float32 or Float64, or if CanSet() is false.
</p>
<h4 id="Value.SetInt" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1395">SetInt</a> <a class="permalink" href="#Value.SetInt">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1395">❖</a><pre>func (v <a href="#Value">Value</a>) SetInt(x <a href="http://godoc.org/builtin#int64">int64</a>)</pre></div><p>
SetInt sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.
</p>
<h4 id="Value.SetLen" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1416">SetLen</a> <a class="permalink" href="#Value.SetLen">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1416">❖</a><pre>func (v <a href="#Value">Value</a>) SetLen(n <a href="http://godoc.org/builtin#int">int</a>)</pre></div><p>
SetLen sets v&#39;s length to n.
It panics if v&#39;s Kind is not Slice or if n is negative or
greater than the capacity of the slice.
</p>
<h4 id="Value.SetMapIndex" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1445">SetMapIndex</a> <a class="permalink" href="#Value.SetMapIndex">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1445">❖</a><pre>func (v <a href="#Value">Value</a>) SetMapIndex(key, val <a href="#Value">Value</a>)</pre></div><p>
SetMapIndex sets the value associated with key in the map v to val.
It panics if v&#39;s Kind is not Map.
If val is the zero Value, SetMapIndex deletes the key from the map.
Otherwise if v holds a nil map, SetMapIndex will panic.
As in Go, key&#39;s value must be assignable to the map&#39;s key type,
and val&#39;s value must be assignable to the map&#39;s value type.
</p>
<h4 id="Value.SetPointer" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1496">SetPointer</a> <a class="permalink" href="#Value.SetPointer">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1496">❖</a><pre>func (v <a href="#Value">Value</a>) SetPointer(x <a href="http://godoc.org/unsafe">unsafe</a>.<a href="http://godoc.org/unsafe#Pointer">Pointer</a>)</pre></div><p>
SetPointer sets the unsafe.Pointer value v to x.
It panics if v&#39;s Kind is not UnsafePointer.
</p>
<h4 id="Value.SetString" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1504">SetString</a> <a class="permalink" href="#Value.SetString">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1504">❖</a><pre>func (v <a href="#Value">Value</a>) SetString(x <a href="http://godoc.org/builtin#string">string</a>)</pre></div><p>
SetString sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not String or if CanSet() is false.
</p>
<h4 id="Value.SetUint" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1474">SetUint</a> <a class="permalink" href="#Value.SetUint">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1474">❖</a><pre>func (v <a href="#Value">Value</a>) SetUint(x <a href="http://godoc.org/builtin#uint64">uint64</a>)</pre></div><p>
SetUint sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.
</p>
<h4 id="Value.Slice" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1513">Slice</a> <a class="permalink" href="#Value.Slice">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1513">❖</a><pre>func (v <a href="#Value">Value</a>) Slice(i, j <a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
Slice returns v[i:j].
It panics if v&#39;s Kind is not Array, Slice or String, or if v is an unaddressable array,
or if the indexes are out of bounds.
</p>
<h4 id="Value.Slice3" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1572">Slice3</a> <a class="permalink" href="#Value.Slice3">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1572">❖</a><pre>func (v <a href="#Value">Value</a>) Slice3(i, j, k <a href="http://godoc.org/builtin#int">int</a>) <a href="#Value">Value</a></pre></div><p>
Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].
It panics if v&#39;s Kind is not Array or Slice, or if v is an unaddressable array,
or if the indexes are out of bounds.
</p>
<h4 id="Value.String" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1627">String</a> <a class="permalink" href="#Value.String">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1627">❖</a><pre>func (v <a href="#Value">Value</a>) String() <a href="http://godoc.org/builtin#string">string</a></pre></div><p>
String returns the string v&#39;s underlying value, as a string.
String is a special case because of Go&#39;s String method convention.
Unlike the other getters, it does not panic if v&#39;s Kind is not String.
Instead, it returns a string of the form &#34;&lt;T value&gt;&#34; where T is v&#39;s type.
The fmt package treats Values specially. It does not call their String
method implicitly but instead prints the concrete values they hold.
</p>
<h4 id="Value.TryRecv" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1644">TryRecv</a> <a class="permalink" href="#Value.TryRecv">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1644">❖</a><pre>func (v <a href="#Value">Value</a>) TryRecv() (x <a href="#Value">Value</a>, ok <a href="http://godoc.org/builtin#bool">bool</a>)</pre></div><p>
TryRecv attempts to receive a value from the channel v but will not block.
It panics if v&#39;s Kind is not Chan.
If the receive delivers a value, x is the transferred value and ok is true.
If the receive cannot finish without blocking, x is the zero Value and ok is false.
If the channel is closed, x is the zero value for the channel&#39;s element type and ok is false.
</p>
<h4 id="Value.TrySend" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1654">TrySend</a> <a class="permalink" href="#Value.TrySend">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1654">❖</a><pre>func (v <a href="#Value">Value</a>) TrySend(x <a href="#Value">Value</a>) <a href="http://godoc.org/builtin#bool">bool</a></pre></div><p>
TrySend attempts to send x on the channel v but will not block.
It panics if v&#39;s Kind is not Chan.
It reports whether the value was sent.
As in Go, x&#39;s value must be assignable to the channel&#39;s element type.
</p>
<h4 id="Value.Type" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1661">Type</a> <a class="permalink" href="#Value.Type">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1661">❖</a><pre>func (v <a href="#Value">Value</a>) Type() <a href="#Type">Type</a></pre></div><p>
Type returns v&#39;s type.
</p>
<h4 id="Value.Uint" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1694">Uint</a> <a class="permalink" href="#Value.Uint">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1694">❖</a><pre>func (v <a href="#Value">Value</a>) Uint() <a href="http://godoc.org/builtin#uint64">uint64</a></pre></div><p>
Uint returns v&#39;s underlying value, as a uint64.
It panics if v&#39;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
</p>
<h4 id="Value.UnsafeAddr" data-kind="m">func (Value) <a title="View Source" href="https://golang.org/src/reflect/value.go#L1717">UnsafeAddr</a> <a class="permalink" href="#Value.UnsafeAddr">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L1717">❖</a><pre>func (v <a href="#Value">Value</a>) UnsafeAddr() <a href="http://godoc.org/builtin#uintptr">uintptr</a></pre></div><p>
UnsafeAddr returns a pointer to v&#39;s data.
It is for advanced clients that also import the &#34;unsafe&#34; package.
It panics if v is not addressable.
</p>
<h3 id="ValueError" data-kind="t">type <a title="View Source" href="https://golang.org/src/reflect/value.go#L148">ValueError</a> <a class="permalink" href="#ValueError">&para;</a></h3>
<div class="decl" data-kind="d"><a title="View Source" href="https://golang.org/src/reflect/value.go#L148">❖</a><pre>type ValueError struct {
    <span id="ValueError.Method">Method</span> <a href="http://godoc.org/builtin#string">string</a>
    <span id="ValueError.Kind">Kind</span>   <a href="#Kind">Kind</a>
}</pre></div><p>
A ValueError occurs when a Value method is invoked on
a Value that does not support it.  Such cases are documented
in the description of each method.
</p>
<h4 id="ValueError.Error" data-kind="m">func (*ValueError) <a title="View Source" href="https://golang.org/src/reflect/value.go#L153">Error</a> <a class="permalink" href="#ValueError.Error">&para;</a></h4>
<div class="funcdecl decl"><a title="View Source" href="https://golang.org/src/reflect/value.go#L153">❖</a><pre>func (e *<a href="#ValueError">ValueError</a>) Error() <a href="http://godoc.org/builtin#string">string</a></pre></div>
<h3 id="pkg-note-bug">Bugs <a class="permalink" href="#pkg-note-bug">&para;</a></h3><p><a title="View Source" href="https://golang.org/src/reflect/type.go#L195">☞</a> FieldByName and related functions consider struct field names to be equal
if the names are equal, even if they are unexported names originating
in different packages. The practical effect of this is that the result of
t.FieldByName(&#34;x&#34;) is not well defined if the struct type t contains
multiple fields named x (embedded from different packages).
FieldByName may return one of the fields named x or may report that there are none.
See golang.org/issue/4876 for more details.



<div id="x-pkginfo">
<form name="x-refresh" method="POST" action="/-/refresh"><input type="hidden" name="path" value="reflect" /></form>
<p>Package reflect imports <a href="?imports">5 packages</a> (<a href="?import-graph">graph</a>) and is imported by <a href="?importers">14384 packages</a>.
  Updated <span class="timeago" title="2016-01-14T00:42:02Z">2016-01-14</span>.
  <a href="javascript:document.getElementsByName('x-refresh')[0].submit();" title="Refresh this page from the source.">Refresh now</a>.
  <a href="?tools">Tools</a> for package owners.
  


</p></div>
<div id="x-jump" tabindex="-1" class="modal">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<h4 class="modal-title">Jump to identifier</h4>
<br class="clearfix" />
<input id="x-jump-filter" class="form-control" autocomplete="off" type="text" />
</div>
<div id="x-jump-body" class="modal-body" style="height: 260px; overflow: auto;">
<div id="x-jump-list" class="list-group" style="margin-bottom: 0;"></div>
</div>
<div class="modal-footer">
<button type="button" class="btn" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>
</p></div>
<div id="x-footer" class="clearfix">
<div class="container">
<a href="https://github.com/golang/gddo/issues">Website Issues</a>
<span class="text-muted">|</span> <a href="http://golang.org/">Go Language</a>
<span class="pull-right"><a href="#">Back to top</a></span>
</div>
</div>
<div id="x-shortcuts" tabindex="-1" class="modal">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
<h4 class="modal-title">Keyboard shortcuts</h4>
</div>
<div class="modal-body">
<table>
<tr><td align="right"><b>?</b></td><td> : This menu</td></tr>
<tr><td align="right"><b>/</b></td><td> : Search site</td></tr>
<tr><td align="right"><b>f</b></td><td> : Jump to identifier</td></tr>
<tr><td align="right"><b>g</b> then <b>g</b></td><td> : Go to top of page</td></tr>
<tr><td align="right"><b>g</b> then <b>b</b></td><td> : Go to end of page</td></tr>
<tr><td align="right"><b>g</b> then <b>i</b></td><td> : Go to index</td></tr>
<tr><td align="right"><b>g</b> then <b>e</b></td><td> : Go to examples</td></tr>
</table>
</div>
<div class="modal-footer">
<button type="button" class="btn" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>
<script src="http://godoc.org//code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="http://godoc.org//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
<script src="http://godoc.org/-/site.js?v=371de731c18d91c499d90b1ab0bf39ecf66d6cf7"></script>
</body>
</html>
